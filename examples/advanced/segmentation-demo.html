<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ONNX æŠ å›¾æ¨¡å‹æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .content {
            padding: 30px;
        }

        .status {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status.loading {
            background: #fef3c7;
            color: #92400e;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .model-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .model-selector select {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .image-container {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .image-container h3 {
            margin-bottom: 10px;
            color: #374151;
        }

        .image-container canvas {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .file-upload {
            margin-bottom: 20px;
        }

        .file-upload input[type="file"] {
            padding: 10px;
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            width: 100%;
            cursor: pointer;
        }

        .performance-info {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .performance-info h3 {
            margin-bottom: 10px;
            color: #374151;
        }

        .performance-metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .performance-metric:last-child {
            border-bottom: none;
        }

        .log-container {
            background: #1f2937;
            color: #e5e7eb;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.info {
            color: #60a5fa;
        }

        .log-entry.success {
            color: #34d399;
        }

        .log-entry.warning {
            color: #fbbf24;
        }

        .log-entry.error {
            color: #f87171;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }

            .image-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ­ RMBG æŠ å›¾æ¼”ç¤º</h1>
            <p>ä½¿ç”¨ RMBG Quantized æ¨¡å‹è¿›è¡Œé«˜è´¨é‡èƒŒæ™¯åˆ†ç¦» | æ¨¡å‹æ¥æº: ModelScope</p>
        </div>

        <div class="content">
            <div id="status" class="status loading">æ­£åœ¨åˆå§‹åŒ–...</div>

            <div class="controls">
                <button class="btn btn-primary" onclick="loadModel()" id="loadBtn" disabled>
                    ğŸŒ ä» ModelScope åŠ è½½ RMBG æ¨¡å‹
                </button>

                <button class="btn btn-primary" onclick="processImage()" id="processBtn" disabled>
                    âœ¨ å¤„ç†å›¾ç‰‡
                </button>

                
                <button class="btn btn-secondary" onclick="useExampleImage()">
                    ğŸ“· ä½¿ç”¨ç¤ºä¾‹å›¾ç‰‡
                </button>

                <button class="btn btn-secondary" onclick="downloadHighResResult()" id="downloadBtn" disabled>
                    ğŸ’¾ ä¸‹è½½é«˜æ¸…ç»“æœ
                </button>

                <button class="btn btn-secondary" onclick="clearResults()">
                    ğŸ—‘ï¸ æ¸…é™¤ç»“æœ
                </button>
            </div>

            <div class="file-upload">
                <input type="file" id="fileInput" accept="image/*" onchange="handleFileSelect(event)">
                <p style="margin-top: 10px; color: #6b7280;">é€‰æ‹©ä¸€å¼ å›¾ç‰‡æˆ–ç‚¹å‡»"ä½¿ç”¨ç¤ºä¾‹å›¾ç‰‡"</p>
            </div>

            <div class="image-grid">
                <div class="image-container">
                    <h3>ğŸ“¸ åŸå§‹å›¾ç‰‡</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>

                <div class="image-container">
                    <h3>ğŸ­ æŠ å›¾ç»“æœ</h3>
                    <canvas id="resultCanvas"></canvas>
                </div>

                <div class="image-container">
                    <h3>ğŸ–¼ï¸ è’™ç‰ˆ</h3>
                    <canvas id="maskCanvas"></canvas>
                </div>
            </div>

            <div class="performance-info" id="performanceInfo" style="display: none;">
                <h3>ğŸ“Š æ€§èƒ½ä¿¡æ¯</h3>
                <div class="performance-metric">
                    <span>æ¨¡å‹åŠ è½½æ—¶é—´:</span>
                    <span id="loadTime">-</span>
                </div>
                <div class="performance-metric">
                    <span>å›¾ç‰‡å¤„ç†æ—¶é—´:</span>
                    <span id="processTime">-</span>
                </div>
                <div class="performance-metric">
                    <span>æ¨¡å‹æ ¼å¼:</span>
                    <span id="modelFormat">-</span>
                </div>
                <div class="performance-metric">
                    <span>æ‰§è¡Œæä¾›è€…:</span>
                    <span id="executionProvider">-</span>
                </div>
            </div>

            <div class="log-container" id="logContainer">
                <div class="log-entry info">ç³»ç»Ÿå‡†å¤‡å°±ç»ª...</div>
            </div>
        </div>
    </div>

    <script type="module">
        import ONNXWebFramework from '../src/onnx-web-framework.js';

        // å…¨å±€å˜é‡
        let framework = null;
        let currentModel = null;
        let currentImageData = null;
        
        
        
        // æ—¥å¿—ç³»ç»Ÿ
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // æ›´æ–°çŠ¶æ€
        function showStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        // åˆå§‹åŒ–æ¡†æ¶
        async function initializeFramework() {
            try {
                log('å¼€å§‹åˆå§‹åŒ– ONNX Web Framework...', 'info');

                framework = new ONNXWebFramework({
                    executionProviders: ['wasm', 'webgl', 'webgpu'],  // å¯ç”¨å¤šä¸ªæ‰§è¡Œæä¾›è€…
                    enableProfiling: true,  // å¯ç”¨æ€§èƒ½åˆ†æ
                    debug: true,
                    useWorker: true,  // å¯ç”¨Worker
                    workerPath: '../src/onnx-worker.js'  // æ­£ç¡®çš„Workerè·¯å¾„
                });

                // è°ƒè¯•ï¼šæ£€æŸ¥é€‰é¡¹æ˜¯å¦æ­£ç¡®è®¾ç½®
                log(`é…ç½®è°ƒè¯•: useWorker=${framework.options.useWorker}`, 'info');
                log(`é…ç½®è°ƒè¯•: workerPath=${framework.options.workerPath}`, 'info');

                await framework.initialize();
                log('âœ… æ¡†æ¶åˆå§‹åŒ–æˆåŠŸ', 'success');

                // æ£€æŸ¥ONNX Runtimeæ˜¯å¦å¯ç”¨ï¼ˆåœ¨æ¡†æ¶åˆå§‹åŒ–åï¼‰
                if (window.ort) {
                    log(`ONNX Runtimeç‰ˆæœ¬: ${window.ort.version || 'unknown'}`, 'info');
                } else {
                    log('âš ï¸ ONNX Runtimeç‰ˆæœ¬ä¿¡æ¯ä¸å¯ç”¨', 'warning');
                }

                // å¯ç”¨æŒ‰é’®
                document.getElementById('loadBtn').disabled = false;

                showStatus('âœ… åˆå§‹åŒ–å®Œæˆï¼Œè¯·åŠ è½½æ¨¡å‹', 'success');

            } catch (error) {
                log(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                log('è¯·æ£€æŸ¥:', 'warning');
                log('1. æ˜¯å¦å®‰è£…äº† onnxruntime-web: pnpm install onnxruntime-web', 'info');
                log('2. æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰å…¶ä»–é”™è¯¯ä¿¡æ¯', 'info');
                log('3. æ£€æŸ¥Viteå¼€å‘æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ', 'info');
                showStatus(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åŠ è½½æ¨¡å‹
        window.loadModel = async function() {
            if (!framework) return;

            const modelName = 'rmbg_quantized'; // å›ºå®šä½¿ç”¨rmbg_quantizedæ¨¡å‹

            try {
                showStatus('æ­£åœ¨åŠ è½½æ¨¡å‹...', 'loading');
                log(`å¼€å§‹ä» ModelScope åŠ è½½æ¨¡å‹: ${modelName}`, 'info');
                log(`æ¨¡å‹åœ°å€: https://www.modelscope.cn/models/duchao/rmbg_quantized/resolve/master/rmbg_quantized.ort`, 'info');

                const loadStart = performance.now();
                // ä» ModelScope åŠ è½½ rmbg_quantized æ¨¡å‹
                await framework.loadModel(modelName, 'https://www.modelscope.cn/models/duchao/rmbg_quantized/resolve/master/rmbg_quantized.ort', {
                    preferOrtFormat: true
                });
                const loadTime = performance.now() - loadStart;

                currentModel = modelName;

                // è·å–æ¨¡å‹ä¿¡æ¯
                const modelInfo = framework.getModelInfo(modelName);
                const modelFormat = framework.getModelFormat(modelName);

                log(`âœ… ä» ModelScope åŠ è½½æ¨¡å‹æˆåŠŸ`, 'success');
                log(`   åŠ è½½æ—¶é—´: ${loadTime.toFixed(2)}ms`);
                log(`   æ ¼å¼: ${modelFormat ? modelFormat.format : 'unknown'}`);
                log(`   æ‰§è¡Œæä¾›è€…: ${modelFormat ? modelFormat.providers.join(', ') : 'unknown'}`);

                // æ˜¾ç¤ºæ¨¡å‹çš„è¾“å…¥è¾“å‡ºä¿¡æ¯
                if (modelInfo) {
                    log(`   è¾“å…¥åç§°: ${modelInfo.inputNames.join(', ')}`, 'info');
                    log(`   è¾“å‡ºåç§°: ${modelInfo.outputNames.join(', ')}`, 'info');
                }

                // æ›´æ–°æ€§èƒ½ä¿¡æ¯
                document.getElementById('loadTime').textContent = `${loadTime.toFixed(2)}ms`;
                document.getElementById('modelFormat').textContent = modelFormat ? modelFormat.format : 'unknown';
                document.getElementById('executionProvider').textContent = modelFormat ? modelFormat.providers.join(', ') : 'unknown';
                document.getElementById('performanceInfo').style.display = 'block';

                // å¯ç”¨å¤„ç†æŒ‰é’®
                document.getElementById('processBtn').disabled = false;

                showStatus('âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼Œå¯ä»¥é€‰æ‹©å›¾ç‰‡è¿›è¡Œå¤„ç†', 'success');

            } catch (error) {
                log(`âŒ æ¨¡å‹åŠ è½½å¤±è´¥: ${error.message}`, 'error');
                showStatus(`âŒ æ¨¡å‹åŠ è½½å¤±è´¥: ${error.message}`, 'error');
            }
        };

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        window.handleFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    displayImage(img);
                    currentImageData = img;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        };

        // ä½¿ç”¨ç¤ºä¾‹å›¾ç‰‡
        window.useExampleImage = function() {
            const img = new Image();
            img.onload = function() {
                displayImage(img);
                currentImageData = img;
                log('âœ… åŠ è½½ç¤ºä¾‹å›¾ç‰‡: photo.jpg', 'success');
            };
            img.onerror = function() {
                log('âŒ æ— æ³•åŠ è½½ç¤ºä¾‹å›¾ç‰‡', 'error');
            };
            img.src = '../examples/photo.jpg';
        };

        // æ˜¾ç¤ºå›¾ç‰‡
        function displayImage(img) {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');

            // è°ƒæ•´canvaså¤§å°
            const maxWidth = 300;
            const scale = Math.min(maxWidth / img.width, maxWidth / img.height, 1);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;

            // ç»˜åˆ¶å›¾ç‰‡
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        // å¤„ç†å›¾ç‰‡
        window.processImage = async function() {
            if (!framework || !currentModel || !currentImageData) return;

            try {
                showStatus('æ­£åœ¨å¤„ç†å›¾ç‰‡...', 'loading');
                log('å¼€å§‹å¤„ç†å›¾ç‰‡...', 'info');

                const processStart = performance.now();

                // é¢„å¤„ç†å›¾ç‰‡
                const processedInput = await preprocessImage(currentImageData);

                // è¿è¡Œæ¨ç†
                const result = await framework.run(currentModel, processedInput);

                const processTime = performance.now() - processStart;

                // åå¤„ç†ç»“æœ
                await postprocessResult(result, currentImageData);

                // æ›´æ–°æ€§èƒ½ä¿¡æ¯
                document.getElementById('processTime').textContent = `${processTime.toFixed(2)}ms`;

                log(`âœ… å›¾ç‰‡å¤„ç†å®Œæˆï¼Œè€—æ—¶: ${processTime.toFixed(2)}ms`, 'success');
                showStatus('âœ… å›¾ç‰‡å¤„ç†å®Œæˆ', 'success');

            } catch (error) {
                log(`âŒ å›¾ç‰‡å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                showStatus(`âŒ å›¾ç‰‡å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            }
        };

        // é¢„å¤„ç†å›¾ç‰‡
        async function preprocessImage(img) {
            const modelName = 'rmbg_quantized'; // å›ºå®šä½¿ç”¨rmbg_quantizedæ¨¡å‹
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // ä½¿ç”¨rmbg_quantizedæ¨¡å‹é…ç½®
            const targetSize = 1024; // rmbg_quantized ä½¿ç”¨ 1024Ã—1024
            const modelConfig = {
                do_normalize: true,
                do_rescale: true,
                rescale_factor: 0.00392156862745098,  // 1/255
                image_mean: [0.5, 0.5, 0.5],
                image_std: [1.0, 1.0, 1.0]
            };
            log(`rmbg_quantizedæ¨¡å‹é…ç½®: ${JSON.stringify(modelConfig)}`, 'info');

            canvas.width = targetSize;
            canvas.height = targetSize;

            // ç»˜åˆ¶å¹¶è°ƒæ•´å¤§å°
            ctx.drawImage(img, 0, 0, targetSize, targetSize);

            // è·å–å›¾åƒæ•°æ®
            const imageData = ctx.getImageData(0, 0, targetSize, targetSize);
            const data = imageData.data;

            // è½¬æ¢ä¸ºNCHWæ ¼å¼ [1, 3, H, W]
            const input = new Float32Array(3 * targetSize * targetSize);

            for (let i = 0; i < data.length; i += 4) {
                const pixelIndex = i / 4;

                // æå–RGBå€¼ (0-255)
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // æ­¥éª¤1: Rescale (å¦‚æœéœ€è¦)
                if (modelConfig.do_rescale) {
                    r = r * modelConfig.rescale_factor;
                    g = g * modelConfig.rescale_factor;
                    b = b * modelConfig.rescale_factor;
                }

                // æ­¥éª¤2: Normalize (å¦‚æœéœ€è¦)
                if (modelConfig.do_normalize) {
                    r = (r - modelConfig.image_mean[0]) / modelConfig.image_std[0];
                    g = (g - modelConfig.image_mean[1]) / modelConfig.image_std[1];
                    b = (b - modelConfig.image_mean[2]) / modelConfig.image_std[2];
                }

                // å­˜å‚¨ä¸ºNCHWæ ¼å¼
                input[pixelIndex] = r;                              // R channel
                input[pixelIndex + targetSize * targetSize] = g;   // G channel
                input[pixelIndex + 2 * targetSize * targetSize] = b; // B channel
            }

            // æ£€æŸ¥ONNX Runtimeæ˜¯å¦å¯ç”¨
            if (!window.ort) {
                throw new Error('ONNX RuntimeæœªåŠ è½½ï¼Œè¯·æ£€æŸ¥onnxruntime-webä¾èµ–');
            }

            // è°ƒè¯•ï¼šè¾“å‡ºå¼ é‡æ•°æ®èŒƒå›´
            let minVal = Infinity, maxVal = -Infinity;
            for (let i = 0; i < Math.min(1000, input.length); i++) {
                minVal = Math.min(minVal, input[i]);
                maxVal = Math.max(maxVal, input[i]);
            }
            log(`${modelName} è¾“å…¥å¼ é‡æ•°æ®èŒƒå›´: [${minVal.toFixed(6)}, ${maxVal.toFixed(6)}]`, 'info');

            // åˆ›å»ºè¾“å…¥å¼ é‡ (NCHWæ ¼å¼: [1, 3, H, W])
            const tensor = new window.ort.Tensor('float32', input, [1, 3, targetSize, targetSize]);

            // è·å–æ¨¡å‹çš„å®é™…è¾“å…¥åç§°
            const modelInfo = framework.getModelInfo(currentModel);
            const inputNames = modelInfo ? modelInfo.inputNames : ['input'];

            log(`ä½¿ç”¨è¾“å…¥åç§°: ${inputNames.join(', ')}`, 'info');

            // æ ¹æ®å®é™…è¾“å…¥åç§°åˆ›å»ºè¾“å…¥å¯¹è±¡
            const inputs = {};
            inputNames.forEach(name => {
                inputs[name] = tensor;
            });

            return inputs;
        }

        // åå¤„ç†ç»“æœ
        async function postprocessResult(result, originalImg) {
            const modelName = 'rmbg_quantized'; // å›ºå®šä½¿ç”¨rmbg_quantizedæ¨¡å‹
            log(`æ¨ç†ç»“æœ: ${JSON.stringify(Object.keys(result))}`, 'info');

            // æ£€æŸ¥resultæ˜¯å¦åŒ…å«å®é™…çš„å¼ é‡è¾“å‡º
            let outputs = [];

            // å¦‚æœresult.outputå­˜åœ¨ä¸”æ˜¯å¯¹è±¡ï¼Œå¯èƒ½åŒ…å«æ‰€æœ‰è¾“å‡º
            if (result.output && typeof result.output === 'object') {
                // å°è¯•æ‰¾åˆ°å®é™…çš„å¼ é‡
                for (const [key, value] of Object.entries(result.output)) {
                    log(`æ£€æŸ¥ result.output.${key}: ç±»å‹=${typeof value}, æœ‰getData=${typeof value.getData === 'function'}`, 'info');
                    if (typeof value === 'object' && value !== null && typeof value.getData === 'function') {
                        outputs.push({ name: key, tensor: value });
                    }
                }
            }

            // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œæ£€æŸ¥resultæœ¬èº«æ˜¯å¦åŒ…å«å¤šä¸ªè¾“å‡º
            if (outputs.length === 0) {
                for (const [key, value] of Object.entries(result)) {
                    log(`æ£€æŸ¥ result.${key}: ç±»å‹=${typeof value}, æœ‰getData=${typeof value.getData === 'function'}`, 'info');
                    if (typeof value === 'object' && value !== null && typeof value.getData === 'function') {
                        outputs.push({ name: key, tensor: value });
                    }
                }
            }

            // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œå¯èƒ½éœ€è¦ç›´æ¥è®¿é—®sessionçš„è¾“å‡º
            if (outputs.length === 0) {
                log('å°è¯•ç›´æ¥ä»sessionè·å–è¾“å‡º...', 'warning');
                const session = framework.sessions.get(currentModel);
                if (session && session.outputNames) {
                    log(`Sessionè¾“å‡ºåç§°: ${session.outputNames.join(', ')}`, 'info');
                    // è¿™é‡Œéœ€è¦é‡æ–°è¿è¡Œæ¨ç†æ¥è·å–å®é™…è¾“å‡º
                    throw new Error('éœ€è¦é‡æ–°è¿è¡Œæ¨ç†ä»¥è·å–å®é™…å¼ é‡è¾“å‡º');
                }
            }

            if (outputs.length === 0) {
                throw new Error('æ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„è¾“å‡ºå¼ é‡');
            }

            // å¯¹äºæŠ å›¾æ¨¡å‹ï¼Œæˆ‘ä»¬é€šå¸¸éœ€è¦ç¬¬ä¸€ä¸ªè¾“å‡º
            const output = outputs[0].tensor;
            log(`ä½¿ç”¨è¾“å‡º: "${outputs[0].name}" (å…±${outputs.length}ä¸ªè¾“å‡º)`, 'success');

            // è·å–å¼ é‡æ•°æ®
            const data = await output.getData();
            log(`è¾“å‡ºæ•°æ®é•¿åº¦: ${data.length}`, 'info');
            log(`è¾“å‡ºç»´åº¦: ${output.dims ? output.dims.join('x') : 'unknown'}`, 'info');

            // åˆ›å»ºè’™ç‰ˆcanvas
            const maskCanvas = document.getElementById('maskCanvas');
            const maskCtx = maskCanvas.getContext('2d');

            // ç¡®å®šè¾“å‡ºç»´åº¦
            let targetSize;
            if (output.dims && output.dims.length >= 2) {
                targetSize = Math.max(output.dims[output.dims.length - 1], output.dims[output.dims.length - 2]);
            } else {
                targetSize = Math.sqrt(data.length);
            }

            maskCanvas.width = targetSize;
            maskCanvas.height = targetSize;

            log(`è’™ç‰ˆå¤§å°: ${targetSize}x${targetSize}`, 'info');

            // å°†ç»“æœè½¬æ¢ä¸ºè’™ç‰ˆ
            const maskImageData = maskCtx.createImageData(targetSize, targetSize);

            // å¤„ç†NCHWæ ¼å¼ [1, 1, 320, 320]
            if (output.dims && output.dims.length === 4) {
                const batchSize = output.dims[0];
                const channels = output.dims[1];
                const height = output.dims[2];
                const width = output.dims[3];

                log(`å¤„ç†NCHWæ ¼å¼: ${batchSize}x${channels}x${height}x${width}`, 'info');

                // æ£€æŸ¥æ•°æ®èŒƒå›´
                let minVal = Infinity, maxVal = -Infinity;
                for (let i = 0; i < Math.min(100, data.length); i++) {
                    minVal = Math.min(minVal, data[i]);
                    maxVal = Math.max(maxVal, data[i]);
                }
                log(`åŸå§‹æ•°æ®èŒƒå›´: [${minVal.toFixed(6)}, ${maxVal.toFixed(6)}]`, 'info');

                // æ ¹æ®æ¨¡å‹å’Œæ•°æ®èŒƒå›´åˆ¤æ–­å¤„ç†æ–¹å¼
                let isProcessedData = maxVal <= 1.0 && minVal >= 0.0;
                let needsAmplification = false;

                // rmbg_quantizedæ¨¡å‹ç‰¹æ®Šå¤„ç†
                // rmbgè¾“å‡ºé€šå¸¸æ˜¯åŸå§‹logitsï¼Œéœ€è¦sigmoidæ¿€æ´»
                log(`æ£€æµ‹åˆ°rmbg_quantizedæ¨¡å‹ï¼Œåº”ç”¨sigmoidæ¿€æ´»å‡½æ•°`, 'info');
                isProcessedData = false;  // éœ€è¦sigmoidå¤„ç†
                needsAmplification = false;

                // åˆ›å»ºä¸´æ—¶æ•°ç»„å­˜å‚¨å¤„ç†åçš„æ•°æ®
                const processedData = new Float32Array(height * width);
                let valueStats = { min: Infinity, max: -Infinity, sum: 0, count: 0 };

                log('å¼€å§‹é«˜çº§æ•°æ®å¤„ç†...', 'info');

                // ç¬¬ä¸€æ­¥ï¼šæ•°æ®é¢„å¤„ç†å’Œå½’ä¸€åŒ–
                for (let h = 0; h < height; h++) {
                    for (let w = 0; w < width; w++) {
                        const dataIndex = h * width + w;  // å•é€šé“
                        const imageIndex = h * width + w;

                        let value = data[dataIndex];

                        // æ•°æ®èŒƒå›´å¤„ç†
                        if (!isProcessedData) {
                            // åº”ç”¨sigmoidæ¿€æ´»ï¼ˆå¦‚æœéœ€è¦ï¼‰
                            if (value > 10 || value < -10) {
                                value = 1 / (1 + Math.exp(-value));
                            }
                            value = Math.max(0, Math.min(1, value));
                        } else if (needsAmplification) {
                            // å½’ä¸€åŒ–æ”¾å¤§
                            if (maxVal > 0) {
                                value = value / maxVal;
                            }
                        }

                        processedData[imageIndex] = value;
                        valueStats.min = Math.min(valueStats.min, value);
                        valueStats.max = Math.max(valueStats.max, value);
                        valueStats.sum += value;
                        valueStats.count++;
                    }
                }

                log(`å¤„ç†åæ•°æ®èŒƒå›´: [${valueStats.min.toFixed(6)}, ${valueStats.max.toFixed(6)}]`, 'info');

                // ç¬¬äºŒæ­¥ï¼šåº”ç”¨Otsuè‡ªé€‚åº”é˜ˆå€¼
                const otsuThreshold = calculateOtsuThreshold(processedData, width, height);
                log(`Otsuè‡ªåŠ¨é˜ˆå€¼: ${otsuThreshold.toFixed(4)}`, 'success');

                // ç¬¬ä¸‰æ­¥ï¼šç”Ÿæˆåˆå§‹trimapï¼ˆèƒŒæ™¯-å‰æ™¯-æœªçŸ¥åŒºåŸŸï¼‰
                const trimap = new Uint8Array(width * height);
                const unknownThreshold = 0.1;  // æœªçŸ¥åŒºåŸŸçš„é˜ˆå€¼èŒƒå›´

                for (let i = 0; i < processedData.length; i++) {
                    if (processedData[i] < otsuThreshold - unknownThreshold) {
                        trimap[i] = 0;      // èƒŒæ™¯
                    } else if (processedData[i] > otsuThreshold + unknownThreshold) {
                        trimap[i] = 255;    // å‰æ™¯
                    } else {
                        trimap[i] = 128;    // æœªçŸ¥åŒºåŸŸ
                    }
                }

                // ç»Ÿè®¡trimapåˆ†å¸ƒ
                let bgCount = 0, fgCount = 0, unknownCount = 0;
                for (let i = 0; i < trimap.length; i++) {
                    if (trimap[i] === 0) bgCount++;
                    else if (trimap[i] === 255) fgCount++;
                    else unknownCount++;
                }
                log(`Trimapåˆ†å¸ƒ - èƒŒæ™¯:${bgCount}, å‰æ™¯:${fgCount}, æœªçŸ¥:${unknownCount}`, 'info');

                // ç¬¬å››æ­¥ï¼šrmbg_quantizedæ¨¡å‹ç®€å•é˜ˆå€¼å¤„ç†
                log('rmbg_quantizedæ¨¡å‹è·³è¿‡å¤æ‚å½¢æ€å­¦å¤„ç†ï¼Œä½¿ç”¨ç®€å•é˜ˆå€¼å¤„ç†', 'info');
                const refinedAlpha = new Float32Array(processedData.length);
                for (let i = 0; i < processedData.length; i++) {
                    refinedAlpha[i] = processedData[i] > 0.5 ? 1.0 : processedData[i];
                }

                // ç¬¬äº”æ­¥ï¼šç™½è¾¹æ¶ˆé™¤å¤„ç† - åŸºäºcode reviewçš„æ­£ç¡®å®ç°
                log('ä½¿ç”¨æ­£ç¡®çš„ç™½è¾¹æ¶ˆé™¤å¤„ç†...', 'info');

                // æ­¥éª¤1: çœŸæ­£çš„smoothstepï¼ˆä¿®å¤ç‰ˆï¼‰
                const smoothstepAlpha = new Float32Array(refinedAlpha.length);
                const edge0 = 0.25;
                const edge1 = 0.75;

                // æ­£ç¡®çš„smoothstepå®ç°
                for (let i = 0; i < refinedAlpha.length; i++) {
                    const value = Math.max(0, Math.min(1, refinedAlpha[i]));
                    smoothstepAlpha[i] = smoothstep01(value, edge0, edge1);
                }

                // æ­¥éª¤2: çœŸæ­£çš„1px erosionï¼ˆmin-filterç‰ˆï¼‰
                const erodedAlpha = alphaErode1px(smoothstepAlpha, width, height);

                // ä½¿ç”¨ç»è¿‡æ­£ç¡®å¤„ç†çš„alpha
                const finalAlpha = erodedAlpha;

                // æ­¥éª¤3: å°†æœ€ç»ˆç»“æœè½¬æ¢ä¸ºmaskå›¾åƒæ•°æ®
                for (let i = 0; i < erodedAlpha.length; i++) {
                    // å°†å€¼é™åˆ¶åœ¨[0,1]èŒƒå›´å†…
                    const clampedValue = Math.max(0, Math.min(1, erodedAlpha[i]));
                    const alphaValue = Math.round(clampedValue * 255);
                    maskImageData.data[i * 4] = alphaValue;     // R
                    maskImageData.data[i * 4 + 1] = alphaValue; // G
                    maskImageData.data[i * 4 + 2] = alphaValue; // B
                    maskImageData.data[i * 4 + 3] = alphaValue; // A - ä½¿ç”¨alphaValueä½œä¸ºé€æ˜åº¦
                }

                log('âœ… æ­£ç¡®çš„ç™½è¾¹æ¶ˆé™¤å¤„ç†å®Œæˆï¼ˆåŸºäºcode reviewä¿®å¤ï¼‰', 'success');

                log('=== maskå›¾åƒæ•°æ®ç”Ÿæˆå®Œæˆ ===');

                // è°ƒè¯•ï¼šæ£€æŸ¥ç”Ÿæˆçš„maskæ•°æ®
                let maskStats = { min: 255, max: 0, sum: 0, alphaSum: 0 };
                for (let i = 0; i < finalAlpha.length; i++) {
                    const alpha = maskImageData.data[i * 4 + 3];
                    maskStats.min = Math.min(maskStats.min, alpha);
                    maskStats.max = Math.max(maskStats.max, alpha);
                    maskStats.alphaSum += alpha;
                    maskStats.sum += finalAlpha[i];
                }
                log(`Mask AlphaèŒƒå›´: ${maskStats.min}-${maskStats.max}, å¹³å‡Alpha: ${(maskStats.alphaSum/finalAlpha.length).toFixed(1)}`);
                log(`FinalAlphaå¹³å‡å€¼: ${(maskStats.sum/finalAlpha.length).toFixed(6)}`);

                log('é«˜çº§maskå¤„ç†å®Œæˆ', 'success');

                
                // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
                const avgValue = valueStats.sum / valueStats.count;
                log(`=== å¤„ç†åçš„æ•°æ®ç»Ÿè®¡ ===`);
                log(`å¤„ç†åçš„å€¼èŒƒå›´: [${valueStats.min.toFixed(6)}, ${valueStats.max.toFixed(6)}]`);
                log(`å¹³å‡å€¼: ${avgValue.toFixed(6)}`);
                log(`æ˜¯å¦éœ€è¦æ”¾å¤§: ${needsAmplification}`);

                // å¦‚æœæ˜¯å•é€šé“ï¼Œå¤åˆ¶åˆ°å…¶ä»–é€šé“
                if (channels === 1) {
                    for (let i = 0; i < height * width; i++) {
                        const value = maskImageData.data[i * 4];
                        maskImageData.data[i * 4 + 1] = value;
                        maskImageData.data[i * 4 + 2] = value;
                    }
                }

            } else {
                // å…¶ä»–æ ¼å¼ï¼Œå‡è®¾æ˜¯ä¸€ç»´æ•°æ®
                for (let i = 0; i < Math.min(data.length, targetSize * targetSize); i++) {
                    let value = data[i];

                    // åº”ç”¨sigmoidæ¿€æ´»ï¼ˆå¦‚æœéœ€è¦ï¼‰
                    if (value > 10 || value < -10) {
                        value = 1 / (1 + Math.exp(-value));
                    }

                    // ç¡®ä¿å€¼åœ¨[0,1]èŒƒå›´å†…
                    value = Math.max(0, Math.min(1, value));

                    const pixelValue = Math.round(value * 255);
                    maskImageData.data[i * 4] = pixelValue;     // R
                    maskImageData.data[i * 4 + 1] = pixelValue; // G
                    maskImageData.data[i * 4 + 2] = pixelValue; // B
                    maskImageData.data[i * 4 + 3] = pixelValue; // A - ä½¿ç”¨pixelValueä½œä¸ºé€æ˜åº¦
                }
            }

            maskCtx.putImageData(maskImageData, 0, 0);

            // åˆ›å»ºæŠ å›¾ç»“æœcanvas
            const resultCanvas = document.getElementById('resultCanvas');
            const resultCtx = resultCanvas.getContext('2d');

            // åˆ›å»ºé«˜åˆ†è¾¨ç‡å¤„ç†canvasï¼ˆåŸå§‹åˆ†è¾¨ç‡ï¼‰
            const fullResCanvas = document.createElement('canvas');
            const fullResCtx = fullResCanvas.getContext('2d');
            fullResCanvas.width = originalImg.width;
            fullResCanvas.height = originalImg.height;

            // åˆ›å»ºé«˜åˆ†è¾¨ç‡è’™ç‰ˆcanvasï¼ˆåŸå§‹åˆ†è¾¨ç‡ï¼‰
            const fullResMaskCanvas = document.createElement('canvas');
            const fullResMaskCtx = fullResMaskCanvas.getContext('2d');
            fullResMaskCanvas.width = originalImg.width;
            fullResMaskCanvas.height = originalImg.height;

            // å°†ä½åˆ†è¾¨ç‡è’™ç‰ˆç¼©æ”¾åˆ°åŸå§‹åˆ†è¾¨ç‡
            fullResMaskCtx.drawImage(maskCanvas, 0, 0, maskCanvas.width, maskCanvas.height, 0, 0, originalImg.width, originalImg.height);

            // åœ¨é«˜åˆ†è¾¨ç‡canvasä¸Šç»˜åˆ¶åŸå§‹å›¾ç‰‡
            fullResCtx.drawImage(originalImg, 0, 0, originalImg.width, originalImg.height);

            // åº”ç”¨è’™ç‰ˆåˆ°é«˜åˆ†è¾¨ç‡canvas
            const maskData = fullResMaskCtx.getImageData(0, 0, originalImg.width, originalImg.height);
            let nonZeroPixels = 0;
            let totalPixels = 0;

            for (let i = 0; i < maskData.data.length; i += 4) {
                const alpha = maskData.data[i + 3];
                if (alpha > 0) nonZeroPixels++;
                totalPixels++;
            }
            log(`è’™ç‰ˆéé€æ˜åƒç´ : ${nonZeroPixels}/${totalPixels}`, 'info');

            // è¯¦ç»†è°ƒè¯•ï¼šæ£€æŸ¥maskåƒç´ å€¼åˆ†å¸ƒ
            let debugSamples = [];
            let maxAlpha = 0;
            let minAlpha = 255;
            let alphaSum = 0;

            for (let i = 0; i < Math.min(20, maskData.data.length / 4); i++) {
                const r = maskData.data[i * 4];
                const g = maskData.data[i * 4 + 1];
                const b = maskData.data[i * 4 + 2];  // ä¿®å¤ typo
                const a = maskData.data[i * 4 + 3];  // ä¿®å¤ typo
                debugSamples.push(`RGBA(${r}, ${g}, ${b}, ${a})`);
                maxAlpha = Math.max(maxAlpha, a);
                minAlpha = Math.min(minAlpha, a);
                alphaSum += a;
            }

            const avgAlpha = alphaSum / Math.min(20, maskData.data.length / 4);
            log(`å‰20ä¸ªåƒç´ å€¼: [${debugSamples.slice(0, 10).join(', ')}]`, 'info');
            log(`Mask AlphaèŒƒå›´: ${minAlpha}-${maxAlpha}, å¹³å‡: ${avgAlpha.toFixed(1)}`, 'info');

            // å…³é”®è°ƒè¯•ï¼šmaskæ˜¯ä½œä¸ºç°åº¦å›¾è¿˜æ˜¯alphaè’™ç‰ˆä½¿ç”¨ï¼Ÿ
            log(`=== è’™ç‰ˆåº”ç”¨åˆ†æ ===`, 'info');
            log(`å½“å‰ä½¿ç”¨çš„æ–¹æ³•: destination-in åˆæˆæ“ä½œ`, 'info');
            log(`è¿™æ„å‘³ç€maskçš„alphaé€šé“å°†æ§åˆ¶åŸå›¾çš„é€æ˜åº¦`, 'info');

            // æ£€æŸ¥maskæ˜¯å¦é€‚åˆä½œä¸ºalphaè’™ç‰ˆ
            let hasTransparency = false;
            let hasHighContrast = false;

            for (let i = 0; i < maskData.data.length; i += 4) {
                const alpha = maskData.data[i + 3];
                if (alpha < 255 && alpha > 0) hasTransparency = true;
                if (alpha > 200) hasHighContrast = true;  // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿé«˜çš„å¯¹æ¯”åº¦
            }

            log(`MaskåŒ…å«åŠé€æ˜åƒç´ : ${hasTransparency}`, 'info');
            log(`MaskåŒ…å«é«˜å¯¹æ¯”åº¦åŒºåŸŸ: ${hasHighContrast}`, 'info');

            // ä¿å­˜åº”ç”¨è’™ç‰ˆå‰çš„çŠ¶æ€
            const beforeData = fullResCtx.getImageData(0, 0, originalImg.width, originalImg.height);

            // åº”ç”¨è’™ç‰ˆåˆ°é«˜åˆ†è¾¨ç‡canvas
            log('åº”ç”¨è’™ç‰ˆåˆ°é«˜åˆ†è¾¨ç‡canvas...', 'info');
            fullResCtx.globalCompositeOperation = 'destination-in';
            fullResCtx.drawImage(fullResMaskCanvas, 0, 0, originalImg.width, originalImg.height);
            fullResCtx.globalCompositeOperation = 'source-over';

            // âœ… æ ¹æ® rmbg è®¨è®ºæ–‡æ¡£ï¼šç»å¯¹ä¸è¦å¯¹ rmbg åšä»»ä½• unpremultiply alpha å¤„ç†
            // rmbg è¾“å‡ºçš„ RGB æ˜¯åŸå§‹å›¾åƒçš„ RGBï¼ˆæœª premultiplyï¼‰ï¼Œæ‰€ä»¥ä¸éœ€è¦å¤„ç†
            log('âœ… è·³è¿‡ Unpremultiply Alpha å¤„ç†ï¼ˆrmbg æ¨¡å‹ä¸éœ€è¦ï¼‰', 'info');

            // è°ƒè¯•ï¼šæ£€æŸ¥é«˜åˆ†è¾¨ç‡æœ€ç»ˆç»“æœ
            const fullResData = fullResCtx.getImageData(0, 0, originalImg.width, originalImg.height);
            let resultNonZeroPixels = 0;
            let resultMaxAlpha = 0;
            let resultAlphaSum = 0;

            for (let i = 0; i < fullResData.data.length; i += 4) {
                const alpha = fullResData.data[i + 3];
                if (alpha > 0) resultNonZeroPixels++;
                resultMaxAlpha = Math.max(resultMaxAlpha, alpha);
                resultAlphaSum += alpha;
            }

            const resultAvgAlpha = resultAlphaSum / (fullResData.data.length / 4);
            log(`é«˜åˆ†è¾¨ç‡ç»“æœéé€æ˜åƒç´ : ${resultNonZeroPixels}/${originalImg.width * originalImg.height}`, 'info');
            log(`é«˜åˆ†è¾¨ç‡ç»“æœAlphaèŒƒå›´: 0-${resultMaxAlpha}, å¹³å‡: ${resultAvgAlpha.toFixed(1)}`, 'info');

            // å¯¹æ¯”å‰åå˜åŒ–
            let changedPixels = 0;
            for (let i = 0; i < beforeData.data.length; i += 4) {
                const beforeAlpha = beforeData.data[i + 3];
                const afterAlpha = fullResData.data[i + 3];
                if (Math.abs(beforeAlpha - afterAlpha) > 5) {  // æ˜¾è‘—å˜åŒ–
                    changedPixels++;
                }
            }
            log(`å‘ç”Ÿæ˜¾è‘—å˜åŒ–çš„åƒç´ : ${changedPixels}/${originalImg.width * originalImg.height}`, 'info');

            // ç°åœ¨è®¾ç½®æ˜¾ç¤ºç”¨çš„ç¼©æ”¾canvas
            const maxWidth = 300;
            const scale = Math.min(maxWidth / originalImg.width, maxWidth / originalImg.height, 1);
            resultCanvas.width = originalImg.width * scale;
            resultCanvas.height = originalImg.height * scale;

            // å°†é«˜åˆ†è¾¨ç‡ç»“æœç¼©æ”¾åˆ°æ˜¾ç¤ºcanvas
            resultCtx.drawImage(fullResCanvas, 0, 0, originalImg.width, originalImg.height, 0, 0, resultCanvas.width, resultCanvas.height);

            // å­˜å‚¨é«˜åˆ†è¾¨ç‡canvasä¾›ä¸‹è½½ä½¿ç”¨
            window.highResResultCanvas = fullResCanvas;

            // å¯ç”¨ä¸‹è½½æŒ‰é’®
            document.getElementById('downloadBtn').disabled = false;

            log(`âœ… åˆ›å»ºäº† ${originalImg.width}Ã—${originalImg.height} é«˜åˆ†è¾¨ç‡ç»“æœç”¨äºä¸‹è½½`, 'success');

            // å¦‚æœå˜åŒ–å¾ˆå°ï¼Œå°è¯•æ›¿ä»£æ–¹æ³•
            if (changedPixels < (originalImg.width * originalImg.height * 0.1)) {
                log(`âš ï¸ æ£€æµ‹åˆ°è’™ç‰ˆæ•ˆæœä¸æ˜æ˜¾ï¼Œå°è¯•æ›¿ä»£æ–¹æ³•...`, 'warning');

                // åœ¨é«˜åˆ†è¾¨ç‡canvasä¸Šé‡è¯•
                fullResCtx.clearRect(0, 0, originalImg.width, originalImg.height);
                fullResCtx.drawImage(originalImg, 0, 0, originalImg.width, originalImg.height);

                // æ–¹æ³•2ï¼šä½¿ç”¨maskçš„äº®åº¦ä½œä¸ºalphaï¼ˆé«˜åˆ†è¾¨ç‡ç‰ˆæœ¬ï¼‰
                fullResCtx.globalCompositeOperation = 'destination-in';

                // åˆ›å»ºä¸€ä¸ªé«˜åˆ†è¾¨ç‡ä¸´æ—¶canvasæ¥è½¬æ¢ç°åº¦å€¼ä¸ºalpha
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalImg.width;
                tempCanvas.height = originalImg.height;
                const tempCtx = tempCanvas.getContext('2d');

                // å°†é«˜åˆ†è¾¨ç‡maskç»˜åˆ¶åˆ°ä¸´æ—¶canvas
                tempCtx.drawImage(fullResMaskCanvas, 0, 0);
                const tempData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

                // ä½¿ç”¨ç°åº¦å€¼ä½œä¸ºalpha
                for (let i = 0; i < tempData.data.length; i += 4) {
                    const gray = tempData.data[i];  // ä½¿ç”¨çº¢è‰²é€šé“ä½œä¸ºç°åº¦å€¼
                    tempData.data[i] = 255;        // R
                    tempData.data[i + 1] = 255;    // G
                    tempData.data[i + 2] = 255;    // B
                    tempData.data[i + 3] = gray;   // A - ä½¿ç”¨ç°åº¦å€¼ä½œä¸ºé€æ˜åº¦
                }

                tempCtx.putImageData(tempData, 0, 0);
                fullResCtx.drawImage(tempCanvas, 0, 0, originalImg.width, originalImg.height);
                fullResCtx.globalCompositeOperation = 'source-over';

                // æ›´æ–°æ˜¾ç¤ºcanvas
                resultCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
                resultCtx.drawImage(fullResCanvas, 0, 0, originalImg.width, originalImg.height, 0, 0, resultCanvas.width, resultCanvas.height);

                log(`âœ… å°è¯•ä½¿ç”¨ç°åº¦å€¼ä½œä¸ºAlphaè’™ç‰ˆï¼ˆé«˜åˆ†è¾¨ç‡ï¼‰`, 'success');
            }
        }

        // ä¸‹è½½é«˜åˆ†è¾¨ç‡ç»“æœ
        window.downloadHighResResult = function() {
            if (!window.highResResultCanvas) {
                log('âŒ æ²¡æœ‰å¯ä¸‹è½½çš„é«˜åˆ†è¾¨ç‡ç»“æœ', 'error');
                return;
            }

            try {
                // å°†canvasè½¬æ¢ä¸ºblob
                window.highResResultCanvas.toBlob(function(blob) {
                    // åˆ›å»ºä¸‹è½½é“¾æ¥
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `segmentation_result_${Date.now()}.png`;

                    // è§¦å‘ä¸‹è½½
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // æ¸…ç†URLå¯¹è±¡
                    URL.revokeObjectURL(url);

                    log(`âœ… ä¸‹è½½äº†é«˜åˆ†è¾¨ç‡ç»“æœ: ${window.highResResultCanvas.width}Ã—${window.highResResultCanvas.height}`, 'success');
                }, 'image/png');
            } catch (error) {
                log(`âŒ ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
            }
        };

        // æ¸…é™¤ç»“æœ
        window.clearResults = function() {
            const canvases = ['originalCanvas', 'resultCanvas', 'maskCanvas'];
            canvases.forEach(id => {
                const canvas = document.getElementById(id);
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });

            currentImageData = null;
            window.highResResultCanvas = null;
            document.getElementById('performanceInfo').style.display = 'none';
            document.getElementById('downloadBtn').disabled = true;
            log('ç»“æœå·²æ¸…é™¤', 'info');
        };

        // Otsué˜ˆå€¼è®¡ç®—ç®—æ³•
        function calculateOtsuThreshold(data, width, height) {
            // è®¡ç®—ç›´æ–¹å›¾
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < data.length; i++) {
                const bin = Math.min(255, Math.floor(data[i] * 255));
                histogram[bin]++;
            }

            const total = width * height;
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }

            let sumB = 0;
            let wB = 0;
            let wF = 0;
            let varMax = 0;
            let threshold = 0;

            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;

                wF = total - wB;
                if (wF === 0) break;

                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;

                const varBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varBetween > varMax) {
                    varMax = varBetween;
                    threshold = t;
                }
            }

            return threshold / 255.0;  // è½¬æ¢å›[0,1]èŒƒå›´
        }

        // å½¢æ€å­¦ç»†åŒ–å’Œè¾¹ç¼˜å¤„ç†
        function morphologyRefinement(processedData, trimap, width, height) {
            const refinedAlpha = new Float32Array(width * height);

            log('å¼€å§‹å½¢æ€å­¦ç»†åŒ–å¤„ç†...', 'info');

            // ç¬¬ä¸€é˜¶æ®µï¼šå¯¹æœªçŸ¥åŒºåŸŸè¿›è¡Œé«˜æ–¯æ¨¡ç³Šå¤„ç†
            const smoothedData = gaussianBlur(processedData, width, height, 1.0);

            // ç¬¬äºŒé˜¶æ®µï¼šå¼•å¯¼æ»¤æ³¢ç®€åŒ–ç‰ˆæœ¬
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;

                    if (trimap[idx] === 0) {
                        // èƒŒæ™¯åŒºåŸŸ
                        refinedAlpha[idx] = 0;
                    } else if (trimap[idx] === 255) {
                        // å‰æ™¯åŒºåŸŸ
                        refinedAlpha[idx] = 1;
                    } else {
                        // æœªçŸ¥åŒºåŸŸ - ä½¿ç”¨å±€éƒ¨å¹³å‡
                        let localSum = 0;
                        let localCount = 0;
                        const radius = 3;

                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const ny = y + dy;
                                const nx = x + dx;

                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const nIdx = ny * width + nx;
                                    if (trimap[nIdx] !== 0) {  // ä¸åŒ…å«èƒŒæ™¯åƒç´ 
                                        localSum += smoothedData[nIdx];
                                        localCount++;
                                    }
                                }
                            }
                        }

                        if (localCount > 0) {
                            refinedAlpha[idx] = localSum / localCount;
                        } else {
                            refinedAlpha[idx] = smoothedData[idx];
                        }
                    }
                }
            }

            // ç¬¬ä¸‰é˜¶æ®µï¼šè¾¹ç¼˜ç»†åŒ– - å¯¹érmbgæ¨¡å‹ä½¿ç”¨å½¢æ€å­¦æ“ä½œ
            let edgeRefined = refinedAlpha;

            // æ ¹æ®code review: rmbg_quantizedæ¨¡å‹è·³è¿‡å½¢æ€å­¦è¾¹ç¼˜ç»†åŒ–ï¼Œå› ä¸ºå®ƒä¼šæ‰©æ•£halo
            log('è·³è¿‡å½¢æ€å­¦è¾¹ç¼˜ç»†åŒ–ï¼ˆrmbg_quantizedæ¨¡å‹ä¸éœ€è¦ï¼‰', 'info');

            log('å½¢æ€å­¦ç»†åŒ–å¤„ç†å®Œæˆ', 'success');
            return edgeRefined;
        }

        // é«˜æ–¯æ¨¡ç³Š
        function gaussianBlur(data, width, height, sigma) {
            const kernelSize = Math.ceil(3 * sigma);
            const kernel = [];
            const twoSigmaSquare = 2 * sigma * sigma;
            let kernelSum = 0;

            // ç”Ÿæˆé«˜æ–¯æ ¸
            for (let y = -kernelSize; y <= kernelSize; y++) {
                for (let x = -kernelSize; x <= kernelSize; x++) {
                    const weight = Math.exp(-(x * x + y * y) / twoSigmaSquare) / (Math.PI * twoSigmaSquare);
                    kernel.push(weight);
                    kernelSum += weight;
                }
            }

            // å½’ä¸€åŒ–æ ¸
            for (let i = 0; i < kernel.length; i++) {
                kernel[i] /= kernelSum;
            }

            const blurred = new Float32Array(width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let kernelIdx = 0;

                    for (let ky = -kernelSize; ky <= kernelSize; ky++) {
                        for (let kx = -kernelSize; kx <= kernelSize; kx++) {
                            const ny = y + ky;
                            const nx = x + kx;

                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                sum += data[ny * width + nx] * kernel[kernelIdx];
                            }
                            kernelIdx++;
                        }
                    }

                    blurred[y * width + x] = sum;
                }
            }

            return blurred;
        }

        // Alphaè¾¹ç¼˜æ¸…ç† - æ¸©å’Œçš„ç™½è¾¹å¤„ç†
        function alphaErosion(alpha, width, height, radius) {
            const eroded = new Float32Array(alpha.length);
            log(`å¼€å§‹${radius}px alphaè¾¹ç¼˜æ¸…ç†å¤„ç†...`, 'info');

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;

                    // åªæœ‰åœ¨é«˜alphaåŒºåŸŸæ‰åº”ç”¨è…èš€ï¼Œé¿å…è¿‡åº¦å¤„ç†
                    if (alpha[idx] > 0.8) {
                        let hasLowNeighbor = false;

                        // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰ä½alphaåƒç´ ï¼ˆå¯èƒ½çš„ç™½è¾¹ï¼‰
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                if (dy === 0 && dx === 0) continue; // è·³è¿‡è‡ªå·±

                                const ny = y + dy;
                                const nx = x + dx;

                                if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                    const nIdx = ny * width + nx;
                                    if (alpha[nIdx] < 0.3) {
                                        hasLowNeighbor = true;
                                        break;
                                    }
                                }
                            }
                            if (hasLowNeighbor) break;
                        }

                        // å¦‚æœå‘¨å›´æœ‰ä½alphaåƒç´ ï¼Œé™ä½å½“å‰åƒç´ çš„alphaå€¼
                        eroded[idx] = hasLowNeighbor ? alpha[idx] * 0.7 : alpha[idx];
                    } else {
                        // ä½alphaåŒºåŸŸä¿æŒä¸å˜
                        eroded[idx] = alpha[idx];
                    }
                }
            }

            log('âœ… Alphaè¾¹ç¼˜æ¸…ç†å¤„ç†å®Œæˆ', 'success');
            return eroded;
        }

        // æ­£ç¡®çš„smoothstepå‡½æ•°ï¼ˆåŸºäºcode reviewä¿®å¤ç‰ˆï¼‰
        function smoothstep01(x, edge0, edge1) {
            // æ ‡å‡†smoothstep: edge0ä»¥ä¸‹ä¸º0ï¼Œedge1ä»¥ä¸Šä¸º1ï¼Œä¸­é—´å¹³æ»‘è¿‡æ¸¡
            const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
        }

        // çœŸæ­£çš„1px erosionï¼ˆmin-filterç‰ˆï¼‰
        function alphaErode1px(alpha, width, height) {
            const out = new Float32Array(alpha.length);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let minVal = 1.0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const ny = y + dy, nx = x + dx;
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                minVal = Math.min(minVal, alpha[ny * width + nx]);
                            }
                        }
                    }
                    out[y * width + x] = minVal;
                }
            }
            return out;
        }

        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            initializeFramework();
        });
    </script>
</body>
</html>